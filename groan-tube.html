<!DOCTYPE html>
<html lang="es">
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"
    />
    <title>Groan Tube - p5.js + Acelerómetro</title>
    <!-- p5.js y p5.sound desde CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.6.0/addons/p5.sound.min.js"></script>
    <style>
      html,
      body {
        margin: 0;
        padding: 0;
        height: 100%;
        background: #0b0b0f;
        color: #fff;
        font-family: system-ui, Helvetica, Arial;
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
      }
      #ui {
        position: fixed;
        left: 10px;
        right: 10px;
        bottom: 10px;
        background: rgba(255, 255, 255, 0.03);
        border-radius: 12px;
        padding: 10px;
        backdrop-filter: blur(6px);
      }
      .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin: 6px 0;
        flex-wrap: wrap;
      }
      label {
        font-size: 13px;
        width: 110px;
      }
      input[type="range"] {
        flex: 1;
      }
      button {
        padding: 8px 12px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.12);
        background: linear-gradient(#222, #111);
        color: #fff;
        font-weight: 600;
      }
      .small {
        font-size: 12px;
        opacity: 0.9;
      }
      #canvasContainer {
        width: 100%;
        height: calc(100% - 180px);
        display: flex;
        align-items: center;
        justify-content: center;
      }
      #permissionButton {
        background: #0f62fe;
        border: none;
        color: #fff;
        padding: 8px 10px;
        border-radius: 8px;
      }
      .toggle {
        display: flex;
        gap: 6px;
        align-items: center;
      }
    </style>
  </head>
  <body>
    <div id="canvasContainer"></div>

    <div id="ui">
      <div class="row">
        <button id="permissionButton">Enable Motion</button>
        <button id="startSoundButton">Start Sound</button>
        <div style="flex: 1"></div>
        <div class="toggle">
          <input type="checkbox" id="invertX" /><label
            for="invertX"
            class="small"
            >Invert X</label
          >
        </div>
        <div class="toggle">
          <input type="checkbox" id="invertY" /><label
            for="invertY"
            class="small"
            >Invert Y</label
          >
        </div>
      </div>

      <div class="row">
        <label>Sensibilidad</label>
        <input
          id="sens"
          type="range"
          min="0.2"
          max="4"
          step="0.05"
          value="1.2"
        />
        <div class="small" id="sensVal">1.20</div>
      </div>

      <div class="row">
        <label>Pitch min / max</label>
        <input id="pitchMin" type="range" min="40" max="400" value="60" />
        <input id="pitchMax" type="range" min="200" max="2000" value="900" />
        <div class="small" id="pitchVal">60 - 900 Hz</div>
      </div>

      <div class="row">
        <label>Brillo (cutoff)</label>
        <input
          id="brightness"
          type="range"
          min="200"
          max="8000"
          step="10"
          value="1200"
        />
        <div class="small" id="brightVal">1200 Hz</div>
      </div>

      <div class="row small">
        <div>
          Tip: inclina el móvil para cambiar la dirección/pitch. Agítalo
          suavemente para incrementar amplitude (groan).
        </div>
      </div>
    </div>

    <script>
      /*
  Groan Tube: p5.js + p5.sound
  - Usa acelerómetro (devicemotion). Maneja permisos iOS.
  - Oscillator -> Filter -> Env.
  - Mapear:
      * Dirección (ax, ay) -> frecuencia (pitch) y pan
      * Movimiento/Agitación (delta magnitude) -> amplitude / filter resonance
  - Suavizado (low-pass via lerp) para evitar saltos.
*/

      // ---- Config / estado ----
      const CANVAS_SIZE_PERCENT = 0.92;

      let ax = 0,
        ay = 0,
        az = 0; // raw values
      let smoothAx = 0,
        smoothAy = 0,
        smoothAz = 0;
      let lastMag = 0,
        smoothMag = 0;

      let vx = 0,
        vy = 0; // for ball physics (visual)
      let xpos, ypos;

      let invertX = false,
        invertY = false;

      // UI elements
      let permissionButton, startSoundButton;
      let sensSlider,
        sensVal,
        pitchMinS,
        pitchMaxS,
        pitchVal,
        brightS,
        brightVal,
        invertXBox,
        invertYBox;

      let osc,
        filt,
        env,
        ampMonitor,
        playing = false,
        audioStarted = false;

      // smoothing factors
      const MOTION_SMOOTH = 0.14; // lower = smoother
      const MAG_SMOOTH = 0.08;

      // parameters default
      let sensitivity = 1.2;
      let pitchMin = 60;
      let pitchMax = 900;
      let brightnessCutoff = 1200;

      function setup() {
        // create canvas sized for device
        const s = min(windowWidth, windowHeight) * CANVAS_SIZE_PERCENT;
        const canvas = createCanvas(s, s);
        canvas.parent("canvasContainer");
        rectMode(CENTER);
        noStroke();
        fill(255);

        xpos = width / 2;
        ypos = height / 2;

        // sound objects created but not started until user gesture (startSound)
        // note: we only create them now to be safe; oscillator will be started only after resume
        osc = new p5.Oscillator("sawtooth"); // groany timbre
        osc.freq(120);
        osc.amp(0); // controlled by envelope
        filt = new p5.LowPass();
        filt.freq(brightnessCutoff);
        filt.res(1.2);
        // connect oscillator through filter: oscillator -> filter -> master
        osc.disconnect();
        osc.connect(filt);
        filt.disconnect();
        filt.connect(); // connect to master

        env = new p5.Envelope(0.01, 0.6, 0.2, 0.6); // quick attack, sustain-ish, slow release
        // env will control amplitude by calling osc.amp() with ramp (we'll apply env.play)

        // amplitude monitor (not strictly necessary, but useful)
        ampMonitor = new p5.Amplitude();
        ampMonitor.setInput();

        // UI references
        permissionButton = select("#permissionButton");
        startSoundButton = select("#startSoundButton");
        sensSlider = select("#sens");
        sensVal = select("#sensVal");
        pitchMinS = select("#pitchMin");
        pitchMaxS = select("#pitchMax");
        pitchVal = select("#pitchVal");
        brightS = select("#brightness");
        brightVal = select("#brightVal");
        invertXBox = select("#invertX");
        invertYBox = select("#invertY");

        // set initial UI text
        sensVal.html(nf(sensitivity, 1, 2));
        pitchVal.html(pitchMin + " - " + pitchMax + " Hz");
        brightVal.html(brightnessCutoff + " Hz");

        // event listeners
        permissionButton.mousePressed(handleMotionPermission);
        startSoundButton.mousePressed(handleStartSound);

        sensSlider.input(() => {
          sensitivity = parseFloat(sensSlider.value());
          sensVal.html(nf(sensitivity, 1, 2));
        });
        pitchMinS.input(() => {
          pitchMin = parseInt(pitchMinS.value());
          pitchVal.html(pitchMin + " - " + pitchMax + " Hz");
        });
        pitchMaxS.input(() => {
          pitchMax = parseInt(pitchMaxS.value());
          pitchVal.html(pitchMin + " - " + pitchMax + " Hz");
        });
        brightS.input(() => {
          brightnessCutoff = parseInt(brightS.value());
          brightVal.html(brightnessCutoff + " Hz");
          filt.freq(brightnessCutoff);
        });

        invertXBox.changed(() => {
          invertX = invertXBox.elt.checked;
        });
        invertYBox.changed(() => {
          invertY = invertYBox.elt.checked;
        });

        // start listening on non-iOS devices immediately (permission flow will also call startMotion)
        if (
          !(
            typeof DeviceMotionEvent !== "undefined" &&
            typeof DeviceMotionEvent.requestPermission === "function"
          )
        ) {
          startMotion();
        }

        // keep oscillator ready but not audible until user starts
        osc.start();
      }

      function draw() {
        background(8);

        // Smooth device values
        smoothAx += (ax - smoothAx) * MOTION_SMOOTH;
        smoothAy += (ay - smoothAy) * MOTION_SMOOTH;
        smoothAz += (az - smoothAz) * MOTION_SMOOTH;

        // compute magnitude of acceleration (without gravity removal — works for groan effect)
        const mag = sqrt(
          smoothAx * smoothAx + smoothAy * smoothAy + smoothAz * smoothAz
        );
        smoothMag += (mag - smoothMag) * MAG_SMOOTH;

        // control mappings (smoothed)
        // direction: use device X and Y (careful with orientation)
        const { sx, sy } = mapMotionToScreen(smoothAx, smoothAy);
        let dirX = sx * (invertX ? -1 : 1);
        let dirY = sy * (invertY ? -1 : 1);

        // Map direction to pitch: angle or X tilt -> frequency within [pitchMin,pitchMax]
        // We'll use the X position primarily for pitch, and overall magnitude to mod amplitude.
        // Normalize dirX to [-1,1] roughly by dividing by 12 (typical gravity ranges)
        const normX = constrain(dirX / 12.0, -1, 1);
        const targetFreq = map(normX, -1, 1, pitchMin, pitchMax, true);

        // amplitude target based on sudden movement (delta between mag and lastMag)
        const delta = max(0, mag - lastMag);
        lastMag = mag;
        // also use smoothMag baseline so gentle tilt still gives a low amplitude
        const baseAmp = map(smoothMag, 0, 12, 0.02, 0.25, true);
        const shakeAmp = map(delta, 0, 6, 0, 0.9, true);
        const targetAmp = constrain(baseAmp + shakeAmp * sensitivity, 0, 1);

        // filter cutoff responds to magnitude and brightness control
        // brightnessCutoff slider sets center of range; we modulate a little with movement
        const cutoffBase = brightnessCutoff;
        const cutoff = constrain(
          cutoffBase + map(smoothMag, 0, 12, -200, 200),
          60,
          12000
        );

        // Apply smoothing to freq/amp/cutoff to avoid clicks
        // Use lerp-like smoothing
        const CURVE = 0.12;
        const currentFreq = lerp(osc.getFreq(), targetFreq, CURVE);
        osc.freq(currentFreq);

        // Smooth filter
        filt.freq(lerp(filt.freq().value || filt.freq(), cutoff, 0.08));
        filt.res(lerp(filt.res(), map(smoothMag, 0, 12, 0.5, 6), 0.06));

        // Amplitude control via gentle ramp using amp() with time
        // We don't retrigger env each frame; use envelope on strong shakes
        const rms = ampMonitor.getLevel();
        // If big shake (delta threshold), fire env for a groan
        if (delta > 0.8 && audioStarted) {
          // stronger shakes trigger longer/stronger envelope
          const attack = map(delta, 0.8, 6, 0.005, 0.03, true);
          const sus = map(delta, 0.8, 6, 0.4, 0.85, true);
          const rel = map(delta, 0.8, 6, 0.2, 1.2, true);
          env.setADSR(attack, sus, 0.2, rel);
          env.setRange(min(1.0, targetAmp * 1.2), 0);
          // trigger env on oscillator's output -> for p5.Env.play we pass the oscillator
          env.play(osc);
        } else {
          // gentle continuous amplitude to avoid silence, use osc.amp target
          // use slow ramp to avoid clicks
          osc.amp(lerp(osc.getAmp().value || 0, targetAmp * 0.7, 0.06), 0.05); // 50ms ramp
        }

        // Visual: ball that reacts to vx/vy derived from dirX/dirY and mag
        // integrate small physics for ball
        vx += dirX * 0.6 * sensitivity;
        vy += dirY * 0.6 * sensitivity;
        vx *= 0.94;
        vy *= 0.94;
        xpos += vx;
        ypos += vy;

        // Keep in bounds
        const r = 28;
        if (xpos < r) {
          xpos = r;
          vx *= -0.6;
        }
        if (xpos > width - r) {
          xpos = width - r;
          vx *= -0.6;
        }
        if (ypos < r) {
          ypos = r;
          vy *= -0.6;
        }
        if (ypos > height - r) {
          ypos = height - r;
          vy *= -0.6;
        }

        // Draw elements
        // background radial glow
        push();
        translate(width / 2, height / 2);
        noStroke();
        for (let i = 0; i < 6; i++) {
          const a = map(i, 0, 5, 0.08, 0.012);
          fill(180, 20, 30, a * 255);
          ellipse(
            0,
            0,
            width * (0.1 + i * 0.16) * (1 + smoothMag * 0.02),
            height * (0.1 + i * 0.16) * (1 + smoothMag * 0.02)
          );
        }
        pop();

        // direction arrow
        push();
        translate(width / 2, height / 2);
        stroke(255, 200);
        strokeWeight(2);
        fill(255, 120);
        const arrowLen = map(smoothMag, 0, 12, 40, 220);
        const ang = atan2(dirY, dirX);
        push();
        rotate(ang);
        // shaft
        strokeWeight(4);
        line(0, 0, arrowLen, 0);
        // head
        noStroke();
        translate(arrowLen, 0);
        rotate(0);
        triangle(0, -10, 0, 10, 18, 0);
        pop();
        pop();

        // ball
        push();
        noStroke();
        const ampVisual = map(targetAmp, 0, 1, 0.6, 2.6);
        fill(255, 60, 80);
        ellipse(xpos, ypos, r * ampVisual, r * ampVisual);
        // inner darker
        fill(30);
        ellipse(xpos, ypos, r * 0.6 * ampVisual, r * 0.6 * ampVisual);
        pop();

        // HUD text
        push();
        fill(255);
        textSize(13);
        textAlign(LEFT, TOP);
        text(
          "ax: " +
            nf(smoothAx, 1, 2) +
            " ay: " +
            nf(smoothAy, 1, 2) +
            " az: " +
            nf(smoothAz, 1, 2),
          12,
          12
        );
        text("freq: " + nf(osc.getFreq(), 1, 1) + " Hz", 12, 30);
        text(
          "cutoff: " + Math.round(filt.freq().value || filt.freq()) + " Hz",
          12,
          46
        );
        text("amp(target): " + nf(targetAmp, 1, 2), 12, 64);
        pop();

        // intensity bar
        push();
        translate(width - 14, 18);
        rotate(0);
        noStroke();
        const barH = map(smoothMag, 0, 12, 4, height - 60);
        fill(255, 180, 60);
        rect(0, barH / 2 + 8, 12, barH, 6);
        pop();

        // update smoothers
        // (lastMag updated earlier)
      }

      // ---- Motion permission and listener ----
      async function handleMotionPermission() {
        // iOS 13+ requires DeviceMotionEvent.requestPermission call
        if (
          typeof DeviceMotionEvent !== "undefined" &&
          typeof DeviceMotionEvent.requestPermission === "function"
        ) {
          try {
            const resp = await DeviceMotionEvent.requestPermission();
            if (resp === "granted") {
              startMotion();
              permissionButton.elt.disabled = true;
              permissionButton.html("Motion Enabled");
            } else {
              console.warn("Motion permission denied:", resp);
            }
          } catch (err) {
            console.error("Error requesting motion permission:", err);
          }
        } else {
          // not iOS or no explicit permission required
          startMotion();
          permissionButton.elt.disabled = true;
          permissionButton.html("Motion Enabled");
        }
      }

      function startMotion() {
        // prefer accelerationIncludingGravity for maximum compatibility
        window.addEventListener(
          "devicemotion",
          (e) => {
            const a = e.accelerationIncludingGravity || e.acceleration;
            if (!a) return;
            // some browsers provide null or 0 values - guard them
            ax = typeof a.x === "number" ? a.x : ax;
            ay = typeof a.y === "number" ? a.y : ay;
            az = typeof a.z === "number" ? a.z : az;
            // Note: orientation will be mapped in mapMotionToScreen
          },
          true
        );
      }

      // ---- Audio start (user gesture) ----
      async function handleStartSound() {
        // p5 sound / WebAudio requires resume on user gesture
        try {
          await getAudioContext().resume();
          audioStarted = true;
          startSoundButton.elt.disabled = true;
          startSoundButton.html("Sound On");
          playing = true;
          // ensure oscillator is started
          if (!osc.started) osc.start();
          // tiny initial fade-in to avoid click
          osc.amp(0.0001);
        } catch (err) {
          console.error("AudioContext resume error:", err);
        }
      }

      // ---- Helpers from base code: orientation mapping ----
      function getScreenAngle() {
        if (
          screen.orientation &&
          typeof screen.orientation.angle === "number"
        ) {
          return screen.orientation.angle;
        }
        if (typeof window.orientation === "number") {
          return window.orientation;
        }
        return 0;
      }
      function rotate2D(x, y, deg) {
        const rad = (deg * Math.PI) / 180;
        const cosA = Math.cos(rad);
        const sinA = Math.sin(rad);
        return { x: x * cosA - y * sinA, y: x * sinA + y * cosA };
      }
      function mapMotionToScreen(axDev, ayDev) {
        // rotate device vector into current screen orientation
        const ang = getScreenAngle();
        const r = rotate2D(axDev, ayDev, ang);
        let sx = r.x;
        let sy = r.y;
        return { sx, sy };
      }

      // handle window resize
      function windowResized() {
        const s = min(windowWidth, windowHeight) * CANVAS_SIZE_PERCENT;
        resizeCanvas(s, s);
        xpos = constrain(xpos, 0, width);
        ypos = constrain(ypos, 0, height);
      }

      // keyboard shortcuts (handy for debugging in desktop)
      function keyPressed() {
        if (key === "x" || key === "X") {
          invertX = !invertX;
          invertXBox.elt.checked = invertX;
        }
        if (key === "y" || key === "Y") {
          invertY = !invertY;
          invertYBox.elt.checked = invertY;
        }
      }
    </script>
  </body>
</html>
